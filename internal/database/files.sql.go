// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: files.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const countPublicFiles = `-- name: CountPublicFiles :one
select
    count(*)
from files
    where visibility = 'public'
        and is_deleted = false
`

func (q *Queries) CountPublicFiles(ctx context.Context) (int64, error) {
	row := q.queryRow(ctx, q.countPublicFilesStmt, countPublicFiles)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserFiles = `-- name: CountUserFiles :one
select count(*) from files
    where user_id = $1 and is_deleted = false
`

func (q *Queries) CountUserFiles(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.queryRow(ctx, q.countUserFilesStmt, countUserFiles, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createFile = `-- name: CreateFile :one
insert into files (user_id, filename, storage_key, mime_type, size_bytes, checksum)
    values($1, $2, $3, $4, $5, $6)
returning file_id, filename, mime_type, size_bytes, created_at, visibility, checksum, version
`

type CreateFileParams struct {
	UserID     uuid.UUID `json:"user_id"`
	Filename   string    `json:"filename"`
	StorageKey string    `json:"storage_key"`
	MimeType   string    `json:"mime_type"`
	SizeBytes  int64     `json:"size_bytes"`
	Checksum   string    `json:"checksum"`
}

type CreateFileRow struct {
	FileID     uuid.UUID      `json:"file_id"`
	Filename   string         `json:"filename"`
	MimeType   string         `json:"mime_type"`
	SizeBytes  int64          `json:"size_bytes"`
	CreatedAt  time.Time      `json:"created_at"`
	Visibility FileVisibility `json:"visibility"`
	Checksum   string         `json:"checksum"`
	Version    int32          `json:"version"`
}

func (q *Queries) CreateFile(ctx context.Context, arg CreateFileParams) (CreateFileRow, error) {
	row := q.queryRow(ctx, q.createFileStmt, createFile,
		arg.UserID,
		arg.Filename,
		arg.StorageKey,
		arg.MimeType,
		arg.SizeBytes,
		arg.Checksum,
	)
	var i CreateFileRow
	err := row.Scan(
		&i.FileID,
		&i.Filename,
		&i.MimeType,
		&i.SizeBytes,
		&i.CreatedAt,
		&i.Visibility,
		&i.Checksum,
		&i.Version,
	)
	return i, err
}

const deleteFile = `-- name: DeleteFile :exec
update files
    set
        is_deleted = true,
        deleted_at = $1,
        version = version + 1
where file_id = $2
    and version = $3
`

type DeleteFileParams struct {
	DeletedAt sql.NullTime `json:"deleted_at"`
	FileID    uuid.UUID    `json:"file_id"`
	Version   int32        `json:"version"`
}

// Sets file is deleted tag to true and adds a the specified date for a background task to delete it.
func (q *Queries) DeleteFile(ctx context.Context, arg DeleteFileParams) error {
	_, err := q.exec(ctx, q.deleteFileStmt, deleteFile, arg.DeletedAt, arg.FileID, arg.Version)
	return err
}

const getFileByChecksum = `-- name: GetFileByChecksum :one
select
    count(checksum),
    storage_key
from files
    where checksum = $1
        and user_id = $2
        and is_deleted = false
    group by storage_key
`

type GetFileByChecksumParams struct {
	Checksum string    `json:"checksum"`
	UserID   uuid.UUID `json:"user_id"`
}

type GetFileByChecksumRow struct {
	Count      int64  `json:"count"`
	StorageKey string `json:"storage_key"`
}

// GetFileByChecksum function returns an existing file storage key to avoid file duplications
func (q *Queries) GetFileByChecksum(ctx context.Context, arg GetFileByChecksumParams) (GetFileByChecksumRow, error) {
	row := q.queryRow(ctx, q.getFileByChecksumStmt, getFileByChecksum, arg.Checksum, arg.UserID)
	var i GetFileByChecksumRow
	err := row.Scan(&i.Count, &i.StorageKey)
	return i, err
}

const getFileInfo = `-- name: GetFileInfo :one
select
    file_id,
    user_id as owner_id,
    filename,
    mime_type,
    storage_key,
    size_bytes,
    visibility,
    thumbnail_key,
    checksum,
    tags,
    version
from files
    where is_deleted = false
        and file_id = $1
`

type GetFileInfoRow struct {
	FileID       uuid.UUID      `json:"file_id"`
	OwnerID      uuid.UUID      `json:"owner_id"`
	Filename     string         `json:"filename"`
	MimeType     string         `json:"mime_type"`
	StorageKey   string         `json:"storage_key"`
	SizeBytes    int64          `json:"size_bytes"`
	Visibility   FileVisibility `json:"visibility"`
	ThumbnailKey sql.NullString `json:"thumbnail_key"`
	Checksum     string         `json:"checksum"`
	Tags         []string       `json:"tags"`
	Version      int32          `json:"version"`
}

// Retrieve metadata of a file from the database.
func (q *Queries) GetFileInfo(ctx context.Context, fileID uuid.UUID) (GetFileInfoRow, error) {
	row := q.queryRow(ctx, q.getFileInfoStmt, getFileInfo, fileID)
	var i GetFileInfoRow
	err := row.Scan(
		&i.FileID,
		&i.OwnerID,
		&i.Filename,
		&i.MimeType,
		&i.StorageKey,
		&i.SizeBytes,
		&i.Visibility,
		&i.ThumbnailKey,
		&i.Checksum,
		pq.Array(&i.Tags),
		&i.Version,
	)
	return i, err
}

const getFileOwner = `-- name: GetFileOwner :one
select
    u.user_id,
    u.last_name,
    u.first_name,
    u.email
from users u
    join files f
        on u.user_id = f.user_id
        and f.file_id = $1
`

type GetFileOwnerRow struct {
	UserID    uuid.UUID `json:"user_id"`
	LastName  string    `json:"last_name"`
	FirstName string    `json:"first_name"`
	Email     string    `json:"email"`
}

func (q *Queries) GetFileOwner(ctx context.Context, fileID uuid.UUID) (GetFileOwnerRow, error) {
	row := q.queryRow(ctx, q.getFileOwnerStmt, getFileOwner, fileID)
	var i GetFileOwnerRow
	err := row.Scan(
		&i.UserID,
		&i.LastName,
		&i.FirstName,
		&i.Email,
	)
	return i, err
}

const listPublicFiles = `-- name: ListPublicFiles :many
select
    u.user_id as owner_id,
    u.last_name,
    u.first_name,
    f.file_id,
    f.filename,
    f.mime_type,
    f.size_bytes,
    f.thumbnail_key,
    f.checksum,
    f.tags,
    f.version
from files f
    join users u
        on f.user_id = u.user_id
    where f.visibility = 'public'
        and f.is_deleted = false
    order by f.created_at desc
    limit $1 offset $2
`

type ListPublicFilesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListPublicFilesRow struct {
	OwnerID      uuid.UUID      `json:"owner_id"`
	LastName     string         `json:"last_name"`
	FirstName    string         `json:"first_name"`
	FileID       uuid.UUID      `json:"file_id"`
	Filename     string         `json:"filename"`
	MimeType     string         `json:"mime_type"`
	SizeBytes    int64          `json:"size_bytes"`
	ThumbnailKey sql.NullString `json:"thumbnail_key"`
	Checksum     string         `json:"checksum"`
	Tags         []string       `json:"tags"`
	Version      int32          `json:"version"`
}

func (q *Queries) ListPublicFiles(ctx context.Context, arg ListPublicFilesParams) ([]ListPublicFilesRow, error) {
	rows, err := q.query(ctx, q.listPublicFilesStmt, listPublicFiles, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPublicFilesRow{}
	for rows.Next() {
		var i ListPublicFilesRow
		if err := rows.Scan(
			&i.OwnerID,
			&i.LastName,
			&i.FirstName,
			&i.FileID,
			&i.Filename,
			&i.MimeType,
			&i.SizeBytes,
			&i.ThumbnailKey,
			&i.Checksum,
			pq.Array(&i.Tags),
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserFiles = `-- name: ListUserFiles :many
select 
    f.file_id, f.filename, f.mime_type, f.size_bytes, f.visibility, f.created_at, f.tags
from files f
    where f.user_id = $1
        and f.is_deleted = false
    order by f.created_at desc
    limit $2 offset $3
`

type ListUserFilesParams struct {
	UserID uuid.UUID `json:"user_id"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

type ListUserFilesRow struct {
	FileID     uuid.UUID      `json:"file_id"`
	Filename   string         `json:"filename"`
	MimeType   string         `json:"mime_type"`
	SizeBytes  int64          `json:"size_bytes"`
	Visibility FileVisibility `json:"visibility"`
	CreatedAt  time.Time      `json:"created_at"`
	Tags       []string       `json:"tags"`
}

func (q *Queries) ListUserFiles(ctx context.Context, arg ListUserFilesParams) ([]ListUserFilesRow, error) {
	rows, err := q.query(ctx, q.listUserFilesStmt, listUserFiles, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserFilesRow{}
	for rows.Next() {
		var i ListUserFilesRow
		if err := rows.Scan(
			&i.FileID,
			&i.Filename,
			&i.MimeType,
			&i.SizeBytes,
			&i.Visibility,
			&i.CreatedAt,
			pq.Array(&i.Tags),
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setFileVisibility = `-- name: SetFileVisibility :one
update files
    set
        visibility = $1,
        version = version + 1
where file_id = $2
    and version = $3
    returning visibility
`

type SetFileVisibilityParams struct {
	Visibility FileVisibility `json:"visibility"`
	FileID     uuid.UUID      `json:"file_id"`
	Version    int32          `json:"version"`
}

func (q *Queries) SetFileVisibility(ctx context.Context, arg SetFileVisibilityParams) (FileVisibility, error) {
	row := q.queryRow(ctx, q.setFileVisibilityStmt, setFileVisibility, arg.Visibility, arg.FileID, arg.Version)
	var visibility FileVisibility
	err := row.Scan(&visibility)
	return visibility, err
}

const updateFileName = `-- name: UpdateFileName :one
update files
    set
        filename = $1,
        version = version + 1,
        updated_at = now()
where file_id = $2
    and version = $3
returning filename
`

type UpdateFileNameParams struct {
	Filename string    `json:"filename"`
	FileID   uuid.UUID `json:"file_id"`
	Version  int32     `json:"version"`
}

func (q *Queries) UpdateFileName(ctx context.Context, arg UpdateFileNameParams) (string, error) {
	row := q.queryRow(ctx, q.updateFileNameStmt, updateFileName, arg.Filename, arg.FileID, arg.Version)
	var filename string
	err := row.Scan(&filename)
	return filename, err
}
