// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: apikeys.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const checkIfAPIKeyExists = `-- name: CheckIfAPIKeyExists :one
select count(*) from api_keys where prefix = $1
`

func (q *Queries) CheckIfAPIKeyExists(ctx context.Context, prefix string) (int64, error) {
	row := q.queryRow(ctx, q.checkIfAPIKeyExistsStmt, checkIfAPIKeyExists, prefix)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createApiKey = `-- name: CreateApiKey :one
insert into api_keys (
    user_id,
    name,
    key_hash,
    prefix,
    scope,
    expires_at
)
values (
    $1, $2, $3, $4, $5, $6
)
returning api_key_id, user_id, name, key_hash, prefix, scope, is_revoked, revoked_at, created_at, updated_at, expires_at, last_used_at, last_used_ip
`

type CreateApiKeyParams struct {
	UserID    uuid.UUID  `json:"user_id"`
	Name      string     `json:"name"`
	KeyHash   string     `json:"key_hash"`
	Prefix    string     `json:"prefix"`
	Scope     []ApiScope `json:"scope"`
	ExpiresAt time.Time  `json:"expires_at"`
}

func (q *Queries) CreateApiKey(ctx context.Context, arg CreateApiKeyParams) (ApiKey, error) {
	row := q.queryRow(ctx, q.createApiKeyStmt, createApiKey,
		arg.UserID,
		arg.Name,
		arg.KeyHash,
		arg.Prefix,
		pq.Array(arg.Scope),
		arg.ExpiresAt,
	)
	var i ApiKey
	err := row.Scan(
		&i.ApiKeyID,
		&i.UserID,
		&i.Name,
		&i.KeyHash,
		&i.Prefix,
		pq.Array(&i.Scope),
		&i.IsRevoked,
		&i.RevokedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
		&i.LastUsedAt,
		&i.LastUsedIp,
	)
	return i, err
}

const deleteApiKey = `-- name: DeleteApiKey :exec
delete from api_keys
    where api_key_id = $1
`

func (q *Queries) DeleteApiKey(ctx context.Context, apiKeyID uuid.UUID) error {
	_, err := q.exec(ctx, q.deleteApiKeyStmt, deleteApiKey, apiKeyID)
	return err
}

const getApiKeyByPrefix = `-- name: GetApiKeyByPrefix :one
select
    ak.api_key_id,
    ak.key_hash,
    ak.expires_at,
    u.user_id,
    u.first_name,
    u.is_verified,
    u.last_name,
    u.role,
    u.email
from api_keys ak
    join users u using(user_id)
where prefix = $1
`

type GetApiKeyByPrefixRow struct {
	ApiKeyID   uuid.UUID `json:"api_key_id"`
	KeyHash    string    `json:"key_hash"`
	ExpiresAt  time.Time `json:"expires_at"`
	UserID     uuid.UUID `json:"user_id"`
	FirstName  string    `json:"first_name"`
	IsVerified bool      `json:"is_verified"`
	LastName   string    `json:"last_name"`
	Role       UserRole  `json:"role"`
	Email      string    `json:"email"`
}

func (q *Queries) GetApiKeyByPrefix(ctx context.Context, prefix string) (GetApiKeyByPrefixRow, error) {
	row := q.queryRow(ctx, q.getApiKeyByPrefixStmt, getApiKeyByPrefix, prefix)
	var i GetApiKeyByPrefixRow
	err := row.Scan(
		&i.ApiKeyID,
		&i.KeyHash,
		&i.ExpiresAt,
		&i.UserID,
		&i.FirstName,
		&i.IsVerified,
		&i.LastName,
		&i.Role,
		&i.Email,
	)
	return i, err
}

const listApiKeysByUser = `-- name: ListApiKeysByUser :many
select
    api_key_id,
    name,
    prefix,
    scope,
    is_revoked,
    expires_at
from api_keys
    where user_id = $1
order by created_at desc
`

type ListApiKeysByUserRow struct {
	ApiKeyID  uuid.UUID  `json:"api_key_id"`
	Name      string     `json:"name"`
	Prefix    string     `json:"prefix"`
	Scope     []ApiScope `json:"scope"`
	IsRevoked bool       `json:"is_revoked"`
	ExpiresAt time.Time  `json:"expires_at"`
}

func (q *Queries) ListApiKeysByUser(ctx context.Context, userID uuid.UUID) ([]ListApiKeysByUserRow, error) {
	rows, err := q.query(ctx, q.listApiKeysByUserStmt, listApiKeysByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListApiKeysByUserRow{}
	for rows.Next() {
		var i ListApiKeysByUserRow
		if err := rows.Scan(
			&i.ApiKeyID,
			&i.Name,
			&i.Prefix,
			pq.Array(&i.Scope),
			&i.IsRevoked,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revokeApiKey = `-- name: RevokeApiKey :exec
update api_keys
set is_revoked = true,
    revoked_at = now()
where api_key_id = $1
`

func (q *Queries) RevokeApiKey(ctx context.Context, apiKeyID uuid.UUID) error {
	_, err := q.exec(ctx, q.revokeApiKeyStmt, revokeApiKey, apiKeyID)
	return err
}

const updateApiKeyLastUsed = `-- name: UpdateApiKeyLastUsed :exec
update api_keys
    set last_used_at = $2
where api_key_id = $1
`

type UpdateApiKeyLastUsedParams struct {
	ApiKeyID   uuid.UUID    `json:"api_key_id"`
	LastUsedAt sql.NullTime `json:"last_used_at"`
}

func (q *Queries) UpdateApiKeyLastUsed(ctx context.Context, arg UpdateApiKeyLastUsedParams) error {
	_, err := q.exec(ctx, q.updateApiKeyLastUsedStmt, updateApiKeyLastUsed, arg.ApiKeyID, arg.LastUsedAt)
	return err
}
